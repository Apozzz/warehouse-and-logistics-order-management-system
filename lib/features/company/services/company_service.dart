import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:inventory_system/enums/app_page.dart';
import 'package:inventory_system/enums/permission_type.dart';
import 'package:inventory_system/features/company/DAOs/company_dao.dart';
import 'package:inventory_system/features/company/models/company_model.dart';
import 'package:inventory_system/features/company/models/tempcode_model.dart';
import 'package:inventory_system/features/permissions/models/role_permission_model.dart';
import 'package:inventory_system/features/role/DAOs/role_dao.dart';
import 'package:inventory_system/features/role/models/role_model.dart';
import 'package:inventory_system/features/user/DAOs/user_dao.dart';
import 'package:inventory_system/features/user/models/user_model.dart' as user;

class CompanyService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final Random _random = Random();
  final CompanyDAO _companyDAO;
  final RoleDAO _roleDAO;
  final UserDAO _userDAO;

  CompanyService(this._companyDAO, this._roleDAO, this._userDAO);

  // Method to create a new company
  Future<Company> createCompany(
      String name, String address, User ceoUser) async {
    // Create the company object
    var company = Company(
      id: '',
      name: name,
      address: address,
      createdAt: DateTime.now(),
      ceo: ceoUser.uid,
      userRoles: {},
    );

    // Save the company to the database
    company = await _companyDAO.saveCompany(company);

    // Create a list of RolePermission with all permissions for the CEO
    List<RolePermission> ceoPermissions = AppPage.values.map((page) {
      return RolePermission(
          page: page,
          permissions: {for (var type in PermissionType.values) type: true});
    }).toList();

    // Create the CEO role with all permissions
    final ceoRole = await _roleDAO.createRole(
      'CEO',
      ceoPermissions, // This should be a List<RolePermission>
      company.id,
    );

    // Update the company with the new userRoles
    company = company.copyWith(userRoles: {ceoUser.uid: ceoRole.id});

    await _companyDAO.saveCompany(company);

    // Assign company to the CEO user
    await _userDAO.addCompanyToUser(ceoUser.uid, company.id);

    return company;
  }

  // Method to get a company by ID
  Future<Company> getCompany(String companyId) async {
    return _companyDAO.getCompany(companyId);
  }

  // Method to generate a temporary code for joining a company
  Future<TempCode> generateTempCode(String companyId, String roleId) async {
    final code = _generateRandomCode();
    final tempCode = TempCode(
      id: '', // ID will be generated by Firestore
      code: code,
      companyId: companyId,
      roleId: roleId,
      expiration: DateTime.now()
          .add(const Duration(days: 1)), // example expiration time
    );

    final docRef = await _db.collection('tempCodes').add(tempCode.toMap());
    return TempCode(
      id: docRef.id,
      code: code,
      companyId: tempCode.companyId,
      roleId: tempCode.roleId,
      expiration: tempCode.expiration,
    );
  }

  Future<void> joinCompanyWithCode(String code) async {
    final querySnapshot =
        await _db.collection('tempCodes').where('code', isEqualTo: code).get();
    if (querySnapshot.docs.isNotEmpty) {
      final tempCodeDoc = querySnapshot.docs.first;
      final tempCode = TempCode.fromMap(tempCodeDoc.data(), tempCodeDoc.id);
      await joinCompany(tempCode);
    } else {
      throw Exception('Invalid code');
    }
  }

  Future<void> joinCompany(TempCode tempCode) async {
    final user = _auth.currentUser;
    if (user == null) {
      throw Exception('User not signed in');
    }

    return _db.runTransaction((transaction) async {
      final companyDocRef = _db.collection('companies').doc(tempCode.companyId);
      final userDocRef = _db.collection('users').doc(user.uid);

      // Read the documents
      final companySnapshot = await transaction.get(companyDocRef);
      final userSnapshot = await transaction.get(userDocRef);

      if (!companySnapshot.exists) {
        throw Exception('Company does not exist');
      }
      if (!userSnapshot.exists) {
        throw Exception('User does not exist');
      }

      // Process company data
      final companyData = companySnapshot.data();
      if (companyData == null) {
        throw Exception('Company data is null');
      }
      final userRolesMap = companyData['userRoles'] as Map;
      final updatedUserRoles = userRolesMap
          .map((key, value) => MapEntry<String, String>(key, value.toString()));
      updatedUserRoles[user.uid] = tempCode.roleId;

      // Process user data
      final userData = userSnapshot.data();
      if (userData == null) {
        throw Exception('User data is null');
      }
      var userCompanyIds = List<String>.from(userData['companyIds'] ?? []);
      if (!userCompanyIds.contains(tempCode.companyId)) {
        userCompanyIds.add(tempCode.companyId);
      }

      // Write the updated data
      transaction.update(companyDocRef, {'userRoles': updatedUserRoles});
      transaction.update(userDocRef, {'companyIds': userCompanyIds});
    });
  }

  Future<Map<String, Map<String, String>>> getUserRoleNames(
      Company company) async {
    // Filter out user-role pairs where either the userId or roleId are empty
    final validEntries = company.userRoles.entries
        .where((entry) => entry.key.isNotEmpty && entry.value.isNotEmpty)
        .toList();

    // Extract the userIds and roleIds from the valid entries
    final userIds = validEntries.map((e) => e.key).toList();
    final roleIds = validEntries.map((e) => e.value).toList();

    // Get the user and role models from the database
    final users = await _userDAO.getUsersByIds(userIds);
    final roles = await _roleDAO.getRolesByIds(roleIds);

    // Build a map of userIds to their username and role name
    final Map<String, Map<String, String>> userRoleNames = {};
    for (var i = 0; i < validEntries.length; i++) {
      final userId = userIds[i];
      final roleId = roleIds[i];

      // Find the user and role models
      final userModel = users.firstWhere((u) => u.id == userId,
          orElse: () => user.User.empty());
      final roleModel =
          roles.firstWhere((r) => r.id == roleId, orElse: () => Role.empty());

      // Add to the map if both the user and role are valid
      if (userModel.isNotEmpty && roleModel.isNotEmpty) {
        userRoleNames[userId] = {
          'userName': userModel.name,
          'roleName': roleModel.name
        };
      }
    }

    return userRoleNames;
  }

  String _generateRandomCode() {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    return String.fromCharCodes(
      Iterable.generate(
        12, // length of the generated code
        (_) => characters.codeUnitAt(_random.nextInt(characters.length)),
      ),
    );
  }
}
