import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:inventory_system/features/company/DAOs/company_dao.dart';
import 'package:inventory_system/features/company/models/company_model.dart';
import 'package:inventory_system/features/company/models/tempcode_model.dart';
import 'package:inventory_system/features/role/models/roles.dart';
import 'package:inventory_system/features/role/services/role_service.dart';
import 'package:inventory_system/features/user/models/user_model.dart' as user;
import 'package:provider/provider.dart';

class CompanyService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final RoleService _roleService;
  final Random _random = Random();
  final CompanyDAO _companyDAO;

  CompanyService(this._roleService, this._companyDAO);

  // Method to create a new company
  Future<Company> createCompany(
      String name, String address, User ceoUser) async {
    final company = Company(
      id: '', // ID will be generated by Firestore
      name: name,
      address: address,
      createdAt: DateTime.now(),
      ceo: ceoUser.uid,
      userRoles: {},
    );

    final docRef = await _db.collection('companies').add(company.toMap());

    // Create a CEO role for the new company
    final ceoRole = await _roleService.createRole(
      'CEO',
      {Permission.ManageUsers, Permission.ViewFinancialData},
      docRef.id,
    );

    // Assign the CEO role to the CEO user
    final updatedCompany = Company(
      id: docRef.id,
      userRoles: {ceoUser.uid: ceoRole.id},
      name: company.name,
      address: company.address,
      createdAt: company.createdAt,
      ceo: company.ceo, // Preserve the other fields
    );

    await _db
        .collection('companies')
        .doc(docRef.id)
        .set(updatedCompany.toMap());

    return updatedCompany;
  }

  // Method to get a company by ID
  Future<Company> getCompany(String companyId) async {
    return _companyDAO.getCompany(companyId);
  }

  // Method to generate a temporary code for joining a company
  Future<TempCode> generateTempCode(String companyId, String roleId) async {
    final code = _generateRandomCode();
    final tempCode = TempCode(
      id: '', // ID will be generated by Firestore
      code: code,
      companyId: companyId,
      roleId: roleId,
      expiration: DateTime.now()
          .add(const Duration(days: 1)), // example expiration time
    );

    final docRef = await _db.collection('tempCodes').add(tempCode.toMap());
    return TempCode(
      id: docRef.id,
      code: code,
      companyId: tempCode.companyId,
      roleId: tempCode.roleId,
      expiration: tempCode.expiration,
    );
  }

  Future<void> joinCompanyWithCode(String code) async {
    final querySnapshot =
        await _db.collection('tempCodes').where('code', isEqualTo: code).get();
    if (querySnapshot.docs.isNotEmpty) {
      final tempCodeDoc = querySnapshot.docs.first;
      final tempCode = TempCode.fromMap(tempCodeDoc.data(), tempCodeDoc.id);
      await joinCompany(tempCode);
    } else {
      throw Exception('Invalid code');
    }
  }

  Future<void> joinCompany(TempCode tempCode) async {
    final company = await getCompany(tempCode.companyId);
    final user = _auth.currentUser;
    if (user != null) {
      final updatedUserRoles = Map<String, String>.from(company.userRoles);
      updatedUserRoles[user.uid] = tempCode.roleId;

      final updatedCompany = Company(
        id: company.id,
        name: company.name,
        address: company.address,
        createdAt: company.createdAt,
        ceo: company.ceo,
        userRoles: updatedUserRoles,
      );

      await _db
          .collection('companies')
          .doc(company.id)
          .set(updatedCompany.toMap());
    } else {
      throw Exception('User not signed in');
    }
  }

  String _generateRandomCode() {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    return String.fromCharCodes(
      Iterable.generate(
        12, // length of the generated code
        (_) => characters.codeUnitAt(_random.nextInt(characters.length)),
      ),
    );
  }
}
